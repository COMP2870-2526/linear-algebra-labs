# Lab 02: Span, linear independence and bases

```{python}
import numpy

```

## Exercise 1:

In the first exercise, we will see how to perform basic linear algebra operations.

You construct the matrix $$A = \begin{pmatrix} 10 & 1 & 0 & 9 \\ 12.4 & 6 & 1 & 0 \\ 0 & 6 & 0 & 8 \\ 1 & 3.14 & 1 & 0 \end{pmatrix}$$ using the [`numpy`]() command `array`:
```{python}
A = np.array([[10, 1, 0, 9], [12.4, 6, 1, 0], [0, 6, 0, 8], [1, 3.14, 1, 0]])
```
You can check the dimensions of `A` by calling
```{python}
A.shape
```

There are shortcut commands to help with some matrices.
```{python}
identity = np.eye(4) # takes one argument for a 4x4 identity matrix
zeros = np.zeros((4, 4)) # takes one shape argument for a 4x4 matrix of zeros
B = np.empty((4, 4)) # takes one shape argument for a 4x4 matrix with values not initialised to anything in particular
```

We can perform basic matrix operations too:
```{python}
5 * A # scalar multiplication
A + identity # to add matrices
zero @ A # the @ operator is used to do matrix multiplication
A.T # we can call the method T to return (a view of) the transpose of A
```

We can use the same expressions for vectors:
```{python}
a = np.array([1.0, 2.0, 3.0]) # row vector
b = np.array([[4.0], [5.0], [6.0]]) # column vector
```
and compute scalar products very simply too
```{python}
c = np.array([[1.0], [0.0], [-1.0]])
np.dot(b, c)
```

**Warning 1:**
All algorithms we use in this module assume that we are working with double-precision floating-point numbers. We can check the type of the entries of the matrix using the `dtype` method:
```{python}
c.dtype
```
When constructing arrays, we can ensure that we have double-precision floating-point numbers using:
```{python}
d = np.array([1.0, 2.0, 3.0], dtype=float)
d = np.array([1.0, 2.0, 3.0], dtype=np.double) # or
```

**Warning 2:**
In the first lab, you already saw that we cannot simply use the `==` operator to check floating-point numbers are equal. The same holds true when working with arrays with floating-point values.
One simply way to check is to use:
```{python}
tol = 1.0e-8
np.linalg.norm(b - c) < tol
```

## Exercise 2:

From [Definition 3.4](https://comp2870-2526.github.io/linear-algebra-notes/src/lec03.html#def-determinant):

Let $A$ be a square $n \times n$ matrix.

If $n = 2$,
\begin{equation}
\det A = \det \begin{pmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{pmatrix}
= a_{11} a_{22} - a_{21} a_{12}.
\end{equation}

If $n = 3$,
\begin{align*}
\det A & = \det \begin{pmatrix} a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{pmatrix} \\
& = a_{11} (a_{22} a_{33} - a_{23} a_{32}) - a_{12} (a_{21} a_{33} - a_{23}
a_{31}) + a_{13} (a_{21} a_{32} - a_{22} - a_{31}).
\end{align*}

For general $n$, the determinant can be found by, for example, Laplace expansions
$$
\det A = \sum_{j=1}^n (-1)^{j+1} a_{1,j} m_{1,j},
$$
where $a_{1,j}$ is the entry of the first row and $j$th column of $A$ and
$m_{1,j}$ is the determinant of the submatrix obtained by removing the first row
and the $j$th column from $A$.


Write a Python function which takes an $n \times n$ matrix stored as a numpy array and returns the determinant. You should write in the specialisms for the cases $n=2,3$ and use Laplace expansions for the general case.

Test your code on the following examples:

\begin{align*}
A & = \begin{pmatrix}
1 & 2 \\ 3 & 4
\end{pmatrix}, & \det A & = -2 \\
%
B & = \begin{pmatrix}
1 & 2 & 3 \\ 0 & 4 & 5 \\ 1 & 0 & 6
\end{pmatrix}, & \det B = 22 \\
%
C & = \begin{pmatrix}
1 & 2 & 3 & 4 \\
5 & 6 & 7 & 8 \\
2 & 6 & 4 & 8 \\
3 & 1 & 1 & 2
\end{pmatrix}, & \det C = 72.
\end{align*}

**Extension**
Can you improve your implementation by avoiding any copies of the matrices or submatrices?
