# Lab03: Linear systems of equations

```{python}
import numpy as np
```

## Exercise 1: LU factorisation

Implement the algorithm for LU factorisation as described [in the notes](https://comp2870-2526.github.io/linear-algebra-notes/src/lec04.html#sec-LU-factorisation). You should implement a Python function which accepts an $n \times n$ matrix $A$ represented as a numpy array and returns one lower triangular matrix $L$ and one upper triangular matrix $U$ with $A = LU$.

Here is some starter code:
```{python}
def lu_factorisation(A):
    """
    Compute the LU factorisation of a square matrix A.

    The function decomposes a square matrix ``A`` into the product of a lower
    triangular matrix ``L`` and an upper triangular matrix ``U`` such that:

    .. math::
        A = L U

    where ``L`` has unit diagonal elements and ``U`` is upper triangular.

    Parameters
    ----------
    A : numpy.ndarray
        A 2D NumPy array of shape ``(n, n)`` representing the square matrix to
        factorise.

    Returns
    -------
    L : numpy.ndarray
        A lower triangular matrix with shape ``(n, n)`` and unit diagonal.
    U : numpy.ndarray
        An upper triangular matrix with shape ``(n, n)``.
    """
    n, m = A.shape
    if n != m:
        raise ValueError(f"Matrix A is not square {A.shape=}")

    # construct arrays of zeros
    L, U = np.zeros_like(A), np.zeros_like(A)
    
    # ...
```

Test your solution on the matrix $A$:
$$
A = \begin{pmatrix}
4 & 2 & 0 \\ 2 & 3 & 1 \\ 0 & 1 & 2.5
\end{pmatrix}.
$$
First compute the LU factorisation by hand and the use `np.linalg.norm` to compare each part of your solution.

## Exercise 2: Timing LU factorisation

Combine your implementation of LU factorisation with the forwards and backwards solve from the lecture notes to create a solver for a system of linear equations. Compare how long it takes for each part of your code to run against the code for Gaussian elimination from the lecture notes.

Use the following code to help generate the test cases:

```{python}
sizes = [2**j for j in range(1, 10)]

for n in sizes:
    # generate a random system of linear equations of size n
    A_part = np.random.rand(n, n)
    A = np.dot(A_part, A_part.T)
    b = np.random.rand(n, 1)
    
    # do the solve
    ...
```

What do you discover?

## Exercise 3: LU factorisation with pivoting (Extension)

We can improve the stability of LU factorisation by additionally including a pivoting step.

The new algorithm looks like:

1. Initialise $P = I_n$ (the $n \times n$ identity), $L = O_n$ (the $n \times n$ zero matrix) and $U = O_n$.
2. For $k = 1, \ldots n$:

    1. Find the pivot row with the largest $|A_{ik}|$ for $i = k, \ldots, n$. Swap rows $k$ and $p$ in $A$ and store this swap in $P$.
    2. Form $U$ row:
       $$
       U_{kj} = A_{kj} \qquad \text{for } j = k, \ldots, n$
       $$
    3. Form $L$ row:
       $$
       L_{ik} = \frac{A_{ik}}{U_{kk}} \qquad \text{for } i = k+1, \ldots, n$
       $$
    4. Update the remaining submatrix:
       $$
       A_{ij} = A_{ij} - L_{ik} U_{kj} \qquad \text{for } i = k+1, \ldots, n, j=k+1, \ldots n.
       $$
    5. Repeat for next column $k+1$.

Implement this new method and test on the system of linear equations given by:
$$
\begin{pmatrix}
10 & -7 & 0 \\ -3 & 2.1 - \varepsilon & 6 \\ 5 & -1 & 5
\end{pmatrix}
\begin{pmatrix}
x_1 \\ x_2 \\x_3
\end{pmatrix}
= \begin{pmatrix}
7 & 9.9 + \varepsilon & 11
\end{pmatrix}.
$$
Test with $\varepsilon = 10^{-14}$.
